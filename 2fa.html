<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tr√¨nh t·∫°o m√£ 2FA (TOTP) ‚Äî D·ª±a tr√™n string</title>
<style>
  :root {
    --bg:#0f1724; --card:#0b1220; --muted:#94a3b8; 
    --accent:#10b981; --accent-hover:#34d399; 
    --glass:rgba(255,255,255,0.05); --border:rgba(255,255,255,0.08);
  }

  body {
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    background: radial-gradient(circle at top, #0f2027, #08121e 80%);
    color:#e6eef8; display:flex; align-items:center; justify-content:center;
    min-height:100vh; margin:0; padding:24px;
  }

  .card {
    background:var(--card); border-radius:16px; padding:26px; max-width:800px; width:100%;
    box-shadow:0 10px 40px rgba(0,0,0,0.5); border:1px solid var(--border);
    backdrop-filter: blur(10px);
    animation: fadeIn 0.5s ease;
  }

  h1 {margin:0 0 8px 0; font-size:22px;}
  p.lead {margin:0 0 18px 0; color:var(--muted); font-size:14px;}

  .grid {display:grid; grid-template-columns:1fr 240px; gap:20px;}
  .field {display:flex; flex-direction:column; gap:6px;}
  label {font-size:13px; color:var(--muted);}

  input[type="text"], select, input[type="number"] {
    background:var(--glass); border:1px solid var(--border);
    padding:10px 12px; border-radius:8px; color:inherit; font-size:14px;
    transition:border 0.2s ease, background 0.2s ease;
  }
  input:focus, select:focus {outline:none; border-color:var(--accent); background:rgba(16,185,129,0.08);}

  .output {
    display:flex; align-items:center; justify-content:space-between;
    padding:16px; border-radius:12px; background:rgba(255,255,255,0.04);
    margin-top:16px; border:1px solid var(--border);
  }

  .code {
    font-family:"Roboto Mono", monospace; font-size:36px; letter-spacing:6px;
    color:#fff; text-shadow:0 0 8px rgba(16,185,129,0.7);
    user-select:all;
  }

  .muted {color:var(--muted); font-size:13px;}
  .row {display:flex; gap:8px; align-items:center;}

  button {
    background:var(--accent); color:#022; padding:10px 14px; border-radius:8px;
    border:none; font-weight:600; cursor:pointer; transition:all .2s ease;
  }
  button:hover {background:var(--accent-hover); transform:translateY(-1px);}
  button.small {font-size:13px; padding:7px 10px;}

  #copyBtn {
    display:flex; align-items:center; gap:6px; background:#1e293b; color:#fff;
    border:1px solid var(--border); transition:all 0.2s ease;
  }
  #copyBtn:hover {background:#334155;}
  #copyBtn svg {width:14px; height:14px; stroke:#10b981;}

  footer {margin-top:18px; color:var(--muted); font-size:13px; line-height:1.5;}
  code {background:rgba(255,255,255,0.05); padding:2px 4px; border-radius:4px;}
  @media (max-width:720px){ .grid{grid-template-columns:1fr} .code{font-size:30px;} }

  @keyframes fadeIn { from {opacity:0; transform:translateY(10px);} to {opacity:1; transform:translateY(0);} }
</style>
</head>
<body>
  <div class="card" role="main">
    <h1>üîê Tr√¨nh t·∫°o m√£ 2FA (TOTP)</h1>
    <p class="lead">Nh·∫≠p m·ªôt <strong>string</strong> (Base32 ho·∫∑c chu·ªói th∆∞·ªùng). M√£ s·∫Ω ƒë∆∞·ª£c sinh theo chu·∫©n TOTP (RFC 6238).</p>

    <div class="grid">
      <div>
        <div class="field">
          <label for="secret">Secret (Base32 ho·∫∑c b·∫•t k·ª≥ string)</label>
          <input id="secret" type="text" placeholder="V√≠ d·ª•: JBSWY3DPEHPK3PXP ho·∫∑c xanh123!@#">
        </div>

        <div style="display:flex;gap:8px;margin-top:10px;">
          <div style="flex:1">
            <label for="algo">Thu·∫≠t to√°n</label>
            <select id="algo">
              <option value="SHA-1">SHA-1 (m·∫∑c ƒë·ªãnh)</option>
              <option value="SHA-256">SHA-256</option>
              <option value="SHA-512">SHA-512</option>
            </select>
          </div>
          <div style="width:120px">
            <label for="digits">Digits</label>
            <input id="digits" type="number" min="6" max="8" value="6">
          </div>
          <div style="width:100px">
            <label for="period">Period(s)</label>
            <input id="period" type="number" min="10" max="120" value="30">
          </div>
        </div>

        <div style="margin-top:14px;display:flex;gap:8px;flex-wrap:wrap;">
          <button id="genBtn">üîÑ Sinh m√£</button>
          <button id="copyBtn" class="small" title="Copy m√£">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke-width="2" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 9h9a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2V9z"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 3h9a2 2 0 0 1 2 2v3"/></svg>
            Copy m√£
          </button>
          <button id="parseOtpAuth" class="small" title="Parse otpauth:// URI">üîç Parse otpauth</button>
        </div>

        <div class="output" style="margin-top:16px;">
          <div>
            <div class="muted">M√£ hi·ªán t·∫°i</div>
            <div class="code" id="code">------</div>
            <div class="muted" id="timeLeft">‚Äî</div>
          </div>
          <div style="text-align:right">
            <div class="muted">Counter / Step</div>
            <div id="counter" class="muted">‚Äî</div>
            <div style="height:6px"></div>
            <div id="algoInfo" class="muted">‚Äî</div>
          </div>
        </div>

        <footer>
          üí° N·∫øu secret l√† Base32, tr√¨nh s·∫Ω gi·∫£i m√£ Base32; n·∫øu kh√¥ng, tr√¨nh d√πng bytes UTF-8.  
          M√£ kh·ªõp v·ªõi c√°c ·ª©ng d·ª•ng Authenticator khi secret ch√≠nh x√°c.
        </footer>
      </div>

      <div>
        <label>H∆∞·ªõng d·∫´n nhanh</label>
        <div style="background:rgba(255,255,255,0.03);padding:10px;border-radius:8px;color:var(--muted);font-size:13px;line-height:1.5;">
          <p><strong>V√≠ d·ª• secret Base32:</strong><br><code>JBSWY3DPEHPK3PXP</code></p>
          <p><strong>V√≠ d·ª• string t√πy √Ω:</strong><br><code>my-secret-123</code></p>
          <p>B·∫°n c√≥ th·ªÉ d√°n URI otpauth (vd: <code>otpauth://totp/Label?secret=JBSWY3DPEHPK3PXP...</code>) v√† nh·∫•n <strong>Parse otpauth</strong>.</p>
        </div>
      </div>
    </div>
  </div>

<script>
/* ---------- C√°c h√†m logic g·ªëc (gi·ªØ nguy√™n) ---------- */
// (to√†n b·ªô ƒëo·∫°n JS b·∫°n g·ª≠i ·ªü tr√™n, gi·ªØ nguy√™n, ch·ªâ c·∫ßn d√°n ph·∫ßn <script> c≈© c·ªßa b·∫°n v√†o ƒë√¢y)
/* ---------- Utilities ---------- */

// Base32 decode (A-Z2-7, optional padding =) -> Uint8Array
function base32Decode(str) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  let cleaned = str.toUpperCase().replace(/[^A-Z2-7=]/g, "");
  // remove padding for processing but keep track
  cleaned = cleaned.replace(/=+$/,"");
  let bits = 0;
  let value = 0;
  const bytes = [];

  for (let i = 0; i < cleaned.length; i++) {
    const idx = alphabet.indexOf(cleaned[i]);
    if (idx === -1) throw new Error("Kh√¥ng ph·∫£i Base32 h·ª£p l·ªá");
    value = (value << 5) | idx;
    bits += 5;
    if (bits >= 8) {
      bits -= 8;
      bytes.push((value >>> bits) & 0xFF);
    }
  }
  return new Uint8Array(bytes);
}

// convert string to Uint8Array (UTF-8)
function strToUint8(s) {
  return new TextEncoder().encode(s);
}

// dynamic int -> 8-byte array (big endian)
function intTo8Bytes(num) {
  const arr = new Uint8Array(8);
  for (let i = 7; i >= 0; i--) {
    arr[i] = num & 0xff;
    num = num >> 8;
  }
  return arr;
}

// truncation per RFC4226
function dynamicTruncate(hmac) {
  const offset = hmac[hmac.length - 1] & 0x0f;
  const code = ((hmac[offset] & 0x7f) << 24) |
               ((hmac[offset + 1] & 0xff) << 16) |
               ((hmac[offset + 2] & 0xff) << 8) |
               (hmac[offset + 3] & 0xff);
  return code >>> 0;
}

/* ---------- Crypto helpers (WebCrypto) ---------- */

async function importKeyRaw(keyBytes, algo) {
  // algo e.g. "SHA-1", "SHA-256", "SHA-512"
  return crypto.subtle.importKey("raw", keyBytes, { name: "HMAC", hash: { name: algo } }, false, ["sign"]);
}

async function computeHMAC(keyObj, data) {
  const sig = await crypto.subtle.sign("HMAC", keyObj, data);
  return new Uint8Array(sig);
}

/* ---------- TOTP / HOTP ---------- */

// HOTP: given key bytes (Uint8Array), counter (integer), digits, algo -> code
async function hotpFromKey(keyBytes, counter, digits, algo) {
  const key = await importKeyRaw(keyBytes, algo);
  const counterBytes = intTo8Bytes(counter);
  const hmac = await computeHMAC(key, counterBytes);
  const codeInt = dynamicTruncate(hmac);
  const mod = Math.pow(10, digits);
  const code = (codeInt % mod).toString().padStart(digits, "0");
  return code;
}

// TOTP: use time / period to compute counter
async function totpFromKey(keyBytes, forTime, period, digits, algo) {
  const counter = Math.floor(forTime / period);
  const code = await hotpFromKey(keyBytes, counter, digits, algo);
  return { code, counter };
}

/* ---------- UI binding & logic ---------- */

const secretEl = document.getElementById("secret");
const algoEl = document.getElementById("algo");
const digitsEl = document.getElementById("digits");
const periodEl = document.getElementById("period");
const genBtn = document.getElementById("genBtn");
const codeEl = document.getElementById("code");
const timeLeftEl = document.getElementById("timeLeft");
const counterEl = document.getElementById("counter");
const algoInfoEl = document.getElementById("algoInfo");
const copyBtn = document.getElementById("copyBtn");
const parseOtpAuthBtn = document.getElementById("parseOtpAuth");

let lastDisplayed = { code: null, counter: null };

function isLikelyBase32(s) {
  // check if contains only base32 chars (allow spaces and =)
  return /^[A-Z2-7= \t\r\n\-]+$/i.test(s) && /[A-Z2-7]/i.test(s);
}

async function deriveKeyBytesFromInput(input) {
  input = (input||"").trim();
  if (!input) throw new Error("Secret r·ªóng");
  // detect otpauth uri?
  const lower = input.toLowerCase();
  if (lower.startsWith("otpauth://")) {
    // parse secret param if possible
    try {
      const u = new URL(input);
      const s = u.searchParams.get("secret");
      if (s) input = s;
    } catch (e) {
      // ignore
    }
  }

  // If looks like Base32, try decode; otherwise use UTF-8 bytes.
  if (isLikelyBase32(input)) {
    try {
      return base32Decode(input);
    } catch (e) {
      // fallback to utf8
      return strToUint8(input);
    }
  } else {
    return strToUint8(input);
  }
}

async function updateNow() {
  const secret = secretEl.value.trim();
  if (!secret) {
    codeEl.textContent = "------";
    timeLeftEl.textContent = "";
    counterEl.textContent = "‚Äî";
    algoInfoEl.textContent = "";
    return;
  }
  const algoRaw = algoEl.value; // e.g., "SHA-1"
  const algo = algoRaw.replace("-", "").toUpperCase(); // "SHA1" not used; WebCrypto expects "SHA-1" etc
  const digits = parseInt(digitsEl.value, 10) || 6;
  const period = parseInt(periodEl.value, 10) || 30;

  let keyBytes;
  try {
    keyBytes = await deriveKeyBytesFromInput(secret);
  } catch (e) {
    codeEl.textContent = "L·ªói secret";
    timeLeftEl.textContent = e.message;
    return;
  }

  // current UNIX time in seconds
  const now = Math.floor(Date.now() / 1000);
  const step = Math.floor(now / period);
  const timeUntil = period - (now % period);

  try {
    // webcrypto expects hash names "SHA-1","SHA-256","SHA-512"
    const algoName = algoRaw;
    const r = await totpFromKey(keyBytes, now, period, digits, algoName);
    codeEl.textContent = r.code;
    timeLeftEl.textContent = `C√≤n ${timeUntil}s`;
    counterEl.textContent = `${r.counter} (step)`;
    algoInfoEl.textContent = `${algoName}, ${digits} ch·ªØ s·ªë, period ${period}s`;
    lastDisplayed = { code: r.code, counter: r.counter };
  } catch (e) {
    codeEl.textContent = "L·ªói t√≠nh to√°n";
    timeLeftEl.textContent = e.message;
  }
}

let timerHandle = null;
function startTicker() {
  if (timerHandle) clearInterval(timerHandle);
  timerHandle = setInterval(updateNow, 1000);
  updateNow();
}

genBtn.addEventListener("click", updateNow);
copyBtn.addEventListener("click", async () => {
  try {
    const txt = codeEl.textContent.trim();
    await navigator.clipboard.writeText(txt);
    copyBtn.textContent = "ƒê√£ copy";
    setTimeout(()=>copyBtn.textContent="Copy m√£",1000);
  } catch (e) {
    copyBtn.textContent = "Copy l·ªói";
    setTimeout(()=>copyBtn.textContent="Copy m√£",1000);
  }
});

// parse otpauth:// URI into fields
parseOtpAuthBtn.addEventListener("click", () => {
  const v = secretEl.value.trim();
  if (!v.toLowerCase().startsWith("otpauth://")) {
    // maybe user pasted whole URI in secret field; try prompt fallback
    alert("H√£y d√°n URI otpauth:// v√†o √¥ secret r·ªìi nh·∫•n Parse otpauth.");
    return;
  }
  try {
    const u = new URL(v);
    const params = u.searchParams;
    const s = params.get("secret");
    if (s) secretEl.value = s;
    const p = params.get("period"); if (p) periodEl.value = p;
    const d = params.get("digits"); if (d) digitsEl.value = d;
    const a = params.get("algorithm"); if (a) {
      // normalize e.g. SHA1 -> SHA-1
      const alg = a.toUpperCase().replace(/\s+/,"");
      if (alg === "SHA1" || alg === "SHA-1") algoEl.value = "SHA-1";
      if (alg === "SHA256" || alg === "SHA-256") algoEl.value = "SHA-256";
      if (alg === "SHA512" || alg === "SHA-512") algoEl.value = "SHA-512";
    }
    updateNow();
  } catch (e) {
    alert("Kh√¥ng th·ªÉ parse otpauth URI: " + e.message);
  }
});

// auto update when user changes inputs
[secretEl, algoEl, digitsEl, periodEl].forEach(el=>{
  el.addEventListener("input", ()=> {
    // immediate update but keep ticker running
    updateNow();
  });
});

startTicker();

</script>
</body>
</html>
